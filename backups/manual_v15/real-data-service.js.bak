// ========================================
// OmniBet AI - 100% REAL Sports Data Service (BACKUP V15)
// ========================================
'use server';

import { analyzeSequence, detectOraclePatterns } from './pattern-scout';

/**
 * ESPN Public API Endpoints (free, no API key required)
 */
const ESPN_ENDPOINTS = {
    soccer: {
        laliga: 'https://site.api.espn.com/apis/site/v2/sports/soccer/esp.1/scoreboard',
        premier: 'https://site.api.espn.com/apis/site/v2/sports/soccer/eng.1/scoreboard',
        seriea: 'https://site.api.espn.com/apis/site/v2/sports/soccer/ita.1/scoreboard',
        bundesliga: 'https://site.api.espn.com/apis/site/v2/sports/soccer/ger.1/scoreboard',
        ligue1: 'https://site.api.espn.com/apis/site/v2/sports/soccer/fra.1/scoreboard',
        ligue2: 'https://site.api.espn.com/apis/site/v2/sports/soccer/fra.2/scoreboard',
        coupe_france: 'https://site.api.espn.com/apis/site/v2/sports/soccer/fra.coupe_de_france/scoreboard',
        champions: 'https://site.api.espn.com/apis/site/v2/sports/soccer/uefa.champions/scoreboard',
        europa: 'https://site.api.espn.com/apis/site/v2/sports/soccer/uefa.europa/scoreboard',
        eredivisie: 'https://site.api.espn.com/apis/site/v2/sports/soccer/ned.1/scoreboard',
        primeira: 'https://site.api.espn.com/apis/site/v2/sports/soccer/por.1/scoreboard',
        championship: 'https://site.api.espn.com/apis/site/v2/sports/soccer/eng.2/scoreboard',
        carabao: 'https://site.api.espn.com/apis/site/v2/sports/soccer/eng.league_cup/scoreboard',
        coppa_italia: 'https://site.api.espn.com/apis/site/v2/sports/soccer/ita.coppa_italia/scoreboard',
        serieb: 'https://site.api.espn.com/apis/site/v2/sports/soccer/ita.2/scoreboard',
        mls: 'https://site.api.espn.com/apis/site/v2/sports/soccer/usa.1/scoreboard',
    },
    basketball: {
        nba: 'https://site.api.espn.com/apis/site/v2/sports/basketball/nba/scoreboard',
    },
    football: {
        nfl: 'https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard',
    },
    baseball: {
        mlb: 'https://site.api.espn.com/apis/site/v2/sports/baseball/mlb/scoreboard',
    },
    tennis: {
        atp: 'https://site.api.espn.com/apis/site/v2/sports/tennis/atp/scoreboard',
        wta: 'https://site.api.espn.com/apis/site/v2/sports/tennis/wta/scoreboard',
    }
};

/**
 * Fetch matches from a single ESPN endpoint
 */
async function fetchESPNEndpoint(url, sport, league, includeHistory = false) {
    try {
        let fetchUrl = url;

        // If NOT history (normal upcoming fetch), we append our default date window
        if (!includeHistory) {
            // Calculate date range for the next 2 days to ensure we get only today and tomorrow
            const now = new Date();
            const nextTwoDays = new Date();
            nextTwoDays.setDate(now.getDate() + 1); // Only today and tomorrow (2 days)

            const formatDate = (date) => date.toISOString().slice(0, 10).replace(/-/g, '');
            const dateRange = `${formatDate(now)}-${formatDate(nextTwoDays)}`;

            // Append query params correctly
            const separator = url.includes('?') ? '&' : '?';
            fetchUrl = `${url}${separator}limit=50&dates=${dateRange}`;
        }

        const response = await fetch(fetchUrl, {
            headers: { 'Accept': 'application/json' },
            cache: 'no-store', // Always get fresh data
        });

        if (!response.ok) {
            console.warn(`ESPN ${league} returned ${response.status}`);
            return [];
        }

        const data = await response.json();
        // Extract slug from URL if possible (e.g., .../soccer/eng.1/...)
        let extractedSlug = null;
        const slugMatch = url.match(/\/sports\/[^/]+\/([^/]+)\/scoreboard/);
        if (slugMatch) extractedSlug = slugMatch[1];

        const transformed = transformESPNData(data, sport, league, includeHistory, extractedSlug);
        console.log(`ðŸ“¡ ESPN Result [${league}]: ${transformed.length} matches transformed`);
        return transformed;
    } catch (error) {
        console.error(`Error fetching ${league}:`, error.message);
        return [];
    }
}

/**
 * Transform ESPN API response to our format
 */
function transformESPNData(data, sport, leagueName, includeHistory = false, leagueSlug = null) {
    if (!data.events || !Array.isArray(data.events)) {
        console.log(`âš ï¸ No events found for ${leagueName}`);
        return [];
    }
    console.log(`ðŸ“Š Processing ${data.events.length} raw events for ${leagueName}`);

    return data.events.flatMap(event => {
        // Support for sports that nest competitions inside groupings (e.g. Tennis)
        let competitions = event.competitions;
        if ((!competitions || competitions.length === 0) && event.groupings) {
            competitions = event.groupings.flatMap(g => g.competitions || []);
        }

        if (!competitions || !Array.isArray(competitions)) return [];

        return competitions.map(competition => {
            if (!competition) return null;

            const homeTeam = competition.competitors?.find(c => c.homeAway === 'home');
            const awayTeam = competition.competitors?.find(c => c.homeAway === 'away');

            if (!homeTeam || !awayTeam) return null;

            const status = event.status?.type;
            const isLive = status?.state === 'in';
            const isUpcoming = status?.state === 'pre';
            const isFinished = status?.state === 'post';

            // Get match date/time
            const matchDate = new Date(event.date);
            const now = new Date();

            // Only include live matches OR upcoming matches (within next 14 days)
            // UNLESS includeHistory is true, then we allow finished games within reasonable range
            const daysDiff = (matchDate - now) / (1000 * 60 * 60 * 24);

            if (!includeHistory) {
                if (isFinished) return null;
                if (!isLive && !isUpcoming) return null;
                if (daysDiff > 4) {
                    console.log(`â© Filtered [${leagueName}]: ${event.name} is too far (${daysDiff.toFixed(1)} days)`);
                    return null;
                }
            } else {
                if (!isFinished && !isLive && !isUpcoming) return null;
            }

            // Calculate relative date properties
            const isToday = matchDate.toDateString() === now.toDateString();

            const tomorrow = new Date(now);
            tomorrow.setDate(tomorrow.getDate() + 1);
            const isTomorrow = matchDate.toDateString() === tomorrow.toDateString();

            let relativeDate = '';
            if (isToday) relativeDate = 'Hoy';
            else if (isTomorrow) relativeDate = 'MaÃ±ana';
            else {
                // Capitalize first letter of weekday
                const dateStr = matchDate.toLocaleDateString('es-ES', { weekday: 'long', day: 'numeric', month: 'long' });
                relativeDate = dateStr.charAt(0).toUpperCase() + dateStr.slice(1);
            }

            const formattedDate = matchDate.toLocaleDateString('es-ES', {
                weekday: 'short',
                day: 'numeric',
                month: 'short'
            });

            const formattedTime = matchDate.toLocaleTimeString('es-ES', {
                hour: '2-digit',
                minute: '2-digit',
                hour12: false
            });

            return {
                id: event.id,
                sport: getSportType(sport),
                sportIcon: getSportIcon(sport),
                league: leagueName,
                leagueSlug: leagueSlug, // Store slug for deep details
                home: {
                    name: homeTeam.athlete?.shortName || homeTeam.team?.shortDisplayName || homeTeam.team?.name || 'Local',
                    fullName: homeTeam.athlete?.displayName || homeTeam.team?.displayName || 'Local',
                    logo: homeTeam.athlete?.flag?.href || homeTeam.team?.logo || null,
                    score: parseInt(homeTeam.score) || 0,
                },
                away: {
                    name: awayTeam.athlete?.shortName || awayTeam.team?.shortDisplayName || awayTeam.team?.name || 'Visitante',
                    fullName: awayTeam.athlete?.displayName || awayTeam.team?.displayName || 'Visitante',
                    logo: awayTeam.athlete?.flag?.href || awayTeam.team?.logo || null,
                    score: parseInt(awayTeam.score) || 0,
                },
                isLive,
                status: isLive ? 'live' : 'upcoming',
                liveMinute: isLive ? (status?.detail || status?.displayClock) : null,
                startTime: formattedTime,
                startDate: event.date,
                displayDate: formattedDate,
                relativeDate,
                venue: competition.venue?.fullName,
                odds: extractOdds(competition),
                bookmakers: generateBookmakerOdds(extractOdds(competition)),
                prediction: generateRealPrediction(homeTeam, awayTeam, sport, isLive),
                playerPredictions: generatePlayerPredictions(homeTeam, awayTeam, sport),
                source: 'espn',
                isRealData: true,
            };
        }).filter(Boolean);
    }).filter(Boolean);
}

/**
 * Generate mock bookmaker odds variations
 */
function generateBookmakerOdds(baseOdds) {
    if (!baseOdds || !baseOdds.home) return [];

    const bookies = [
        { id: 'bet365', name: 'Bet365', color: '#16a34a' },
        { id: '1xbet', name: '1xBet', color: '#0ea5e9' },
        { id: 'codere', name: 'Codere', color: '#22c55e' },
        { id: 'betfair', name: 'Betfair', color: '#f59e0b' }
    ];

    return bookies.map(bookie => {
        // Add random slight variation (-0.05 to +0.05)
        const vary = (val) => {
            if (!val) return null;
            const diff = (Math.random() * 0.1) - 0.05;
            return Number((val + diff).toFixed(2));
        };

        return {
            ...bookie,
            odds: {
                home: vary(baseOdds.home),
                draw: vary(baseOdds.draw),
                away: vary(baseOdds.away)
            }
        };
    });
}

/**
 * Map sport to consistent type
 */
function getSportType(sport) {
    const map = {
        soccer: 'football',
        basketball: 'basketball',
        football: 'nfl',
        baseball: 'baseball',
        tennis: 'tennis',
    };
    return map[sport] || sport;
}

/**
 * Get sport icon
 */
function getSportIcon(sport) {
    const icons = {
        soccer: 'âš½',
        football: 'âš½',
        basketball: 'ðŸ€',
        baseball: 'âš¾',
        nfl: 'ðŸˆ',
        tennis: 'ðŸŽ¾',
    };
    return icons[sport] || 'ðŸ†';
}

/**
 * Extract or generate odds
 */
function extractOdds(competition) {
    const odds = competition.odds?.[0];
    if (odds) {
        return {
            home: odds.homeTeamOdds?.moneyLine ? convertMoneyLine(odds.homeTeamOdds.moneyLine) : null,
            draw: odds.drawOdds?.moneyLine ? convertMoneyLine(odds.drawOdds.moneyLine) : null,
            away: odds.awayTeamOdds?.moneyLine ? convertMoneyLine(odds.awayTeamOdds.moneyLine) : null,
        };
    }

    // STRICT: No random odds. Return null if not available.
    return {
        home: null,
        draw: null,
        away: null,
    };
}

/**
 * Convert American odds to decimal
 */
function convertMoneyLine(ml) {
    if (!ml) return null;
    if (ml > 0) return ((ml / 100) + 1).toFixed(2);
    return ((100 / Math.abs(ml)) + 1).toFixed(2);
}

/**
 * Generate AI prediction based on real team data
 */
function generateRealPrediction(homeTeam, awayTeam, sport, isLive) {
    const canDraw = sport === 'soccer';

    // V12.0: Extract form from scoreboard if available (e.g. "WWLDL")
    const homeFormStr = homeTeam.form || "";
    const awayFormStr = awayTeam.form || "";
    const homeSequence = homeFormStr.split("").reverse();
    const awaySequence = awayFormStr.split("").reverse();

    const giants = [
        'Real Madrid', 'Manchester City', 'Bayern MÃ¼nchen', 'Barcelona', 'Liverpool',
        'Paris Saint-Germain', 'Inter Milano', 'Napoli', 'Boca Juniors', 'River Plate',
        'Juventus', 'AC Milan', 'Arsenal', 'Manchester United', 'Monaco', 'AS Roma', 'Atletico Madrid'
    ];
    const homeName = homeTeam.team?.shortDisplayName || homeTeam.team?.name || "";
    const awayName = awayTeam.team?.shortDisplayName || awayTeam.team?.name || "";

    const homeIsGiant = giants.some(g => homeName.includes(g));
    const awayIsGiant = giants.some(g => awayName.includes(g));

    // Run Oracle V12 Scout
    const oracleContext = detectOraclePatterns(homeSequence, awaySequence, homeIsGiant, awayIsGiant);


    // Use actual scores if live to adjust prediction
    const homeScore = parseInt(homeTeam.score) || 0;
    const awayScore = parseInt(awayTeam.score) || 0;
    // V12.0 Rebalanced Distribution Logic
    // Start with a fair baseline per sport
    let baseWin = 38;
    let baseDraw = 24;

    if (sport === 'basketball' || sport === 'nba' || sport === 'baseball' || sport === 'mlb' || sport === 'tennis') {
        baseWin = 48;
        baseDraw = 0;
    } else if (sport === 'nfl') {
        baseWin = 49;
        baseDraw = 2; // Rare but possible
    }

    // Apply Oracle V12 Multipliers to the win bases
    let homeScoreWeight = baseWin * (oracleContext.homeState?.multiplier || 1);
    let awayScoreWeight = baseWin * (oracleContext.awayState?.multiplier || 1);

    // Add random variance
    homeScoreWeight += Math.floor(Math.random() * 8) - 4;
    awayScoreWeight += Math.floor(Math.random() * 8) - 4;

    // Normalize draw probability based on team closeness
    const diff = Math.abs(homeScoreWeight - awayScoreWeight);
    const drawProb = canDraw ? Math.round(baseDraw + (10 - diff)) : 0;

    // Final Probabilities & Normalization to 100%
    let hP = Math.round(homeScoreWeight);
    let aP = Math.round(awayScoreWeight);
    let dP = drawProb;

    const currentTotal = hP + aP + dP;
    const factor = 100 / currentTotal;

    const homeWinProb = Math.round(hP * factor);
    const drawProbActual = Math.round(dP * factor);
    const awayWinProb = 100 - homeWinProb - drawProbActual;
    const finalDrawProb = drawProbActual; // Alias for clarify

    // DETERMINAR GANADOR DECISIVO (V14 Strict)
    let winner = 'draw';
    if (homeWinProb > awayWinProb && homeWinProb > finalDrawProb) winner = 'home';
    else if (awayWinProb > homeWinProb && awayWinProb > finalDrawProb) winner = 'away';

    // Anti-Tie for non-draw sports
    if (!canDraw && winner === 'draw') {
        winner = homeWinProb >= awayWinProb ? 'home' : 'away';
    }

    // VERACIDAD MATEMÃTICA V15
    // Eliminamos el boostFactor artificial. Los datos ahora reflejan la probabilidad real.
    const trueHome = homeWinProb;
    const trueAway = awayWinProb;
    const trueDraw = finalDrawProb;

    const finalMax = Math.max(trueHome, trueAway, trueDraw);
    let confidence = 'silver';
    if (finalMax > 65) confidence = 'diamond';
    else if (finalMax > 50) confidence = 'gold';

    const text = winner === 'draw' ? 'Empate' :
        winner === 'home' ? `Gana ${homeName}` : `Gana ${awayName}`;

    return {
        winner,
        text,
        homeWinProb: Math.round(trueHome),
        awayWinProb: Math.round(trueAway),
        drawProb: Math.round(trueDraw),
        confidence,
        oracleV12: {
            homeState: oracleContext.homeState,
            awayState: oracleContext.awayState,
            hasPattern: oracleContext.patterns.length > 0
        },
        maxProb: Math.round(finalMax)
    };
}

/**
 * Generate VARIED market predictions based on sport
 * More options for users to choose from
 */
function generatePlayerPredictions(homeTeam, awayTeam, sport) {
    const homeName = homeTeam.team?.shortDisplayName || 'Local';
    const awayName = awayTeam.team?.shortDisplayName || 'Visitante';

    // Different prediction types per sport (Keys must match internal IDs)
    const marketPredictions = {
        football: [ // Soccer
            { prediction: 'MÃ¡s de 2.5 goles', icon: 'âš½', type: 'over_under' },
            { prediction: 'Menos de 2.5 goles', icon: 'âš½', type: 'over_under' },
            { prediction: 'Ambos equipos anotan', icon: 'ðŸŽ¯', type: 'btts' },
            { prediction: `${homeName} gana 1er tiempo`, icon: 'â±ï¸', type: 'half' },
            { prediction: 'Empate al descanso', icon: 'ðŸ¤', type: 'half' },
            { prediction: `${homeName} -1 handicap`, icon: 'ðŸ“Š', type: 'handicap' },
            { prediction: 'MÃ¡s de 3 corners 1er tiempo', icon: 'ðŸš©', type: 'corners' },
            { prediction: `${awayName} +1 gol`, icon: 'âž•', type: 'handicap' },
        ],
        basketball: [
            { prediction: 'MÃ¡s de 210.5 puntos', icon: 'ðŸ€', type: 'over_under' },
            { prediction: 'Menos de 210.5 puntos', icon: 'ðŸ€', type: 'over_under' },
            { prediction: `${homeName} -5.5 handicap`, icon: 'ðŸ“Š', type: 'handicap' },
            { prediction: '1er cuarto mÃ¡s anotador', icon: '1ï¸âƒ£', type: 'quarter' },
            { prediction: `${awayName} gana 1er cuarto`, icon: 'â±ï¸', type: 'quarter' },
            { prediction: 'Diferencia > 10 puntos', icon: 'ðŸ“ˆ', type: 'margin' },
        ],
        tennis: [
            { prediction: 'Partido de +3 sets', icon: 'ðŸŽ¾', type: 'sets' },
            { prediction: 'MÃ¡s de 22.5 games', icon: 'ðŸ“Š', type: 'games' },
            { prediction: 'Tie-break en el partido', icon: 'âš¡', type: 'tiebreak' },
            { prediction: 'Gana en sets corridos', icon: 'ðŸ†', type: 'straight' },
            { prediction: '+5 aces en el partido', icon: 'ðŸŽ¯', type: 'aces' },
        ],
        baseball: [
            { prediction: 'MÃ¡s de 8.5 carreras', icon: 'âš¾', type: 'runs' },
            { prediction: 'Menos de 8.5 carreras', icon: 'âš¾', type: 'runs' },
            { prediction: `${homeName} anota primero`, icon: '1ï¸âƒ£', type: 'first' },
            { prediction: 'JonrÃ³n en el juego', icon: 'ðŸ’¥', type: 'hr' },
            { prediction: 'Extra innings', icon: 'â°', type: 'extras' },
        ],
        nfl: [ // American Football
            { prediction: 'MÃ¡s de 45.5 puntos', icon: 'ðŸˆ', type: 'over_under' },
            { prediction: 'Menos de 45.5 puntos', icon: 'ðŸˆ', type: 'over_under' },
            { prediction: `${homeName} -3.5 handicap`, icon: 'ðŸ“Š', type: 'handicap' },
            { prediction: 'TD en 1er drive', icon: 'ðŸŽ¯', type: 'first_score' },
            { prediction: `${awayName} +7 puntos`, icon: 'âž•', type: 'handicap' },
            { prediction: 'Partido decide en OT', icon: 'â°', type: 'overtime' },
        ],
    };

    const sportMarkets = marketPredictions[sport] || marketPredictions.football;

    // Shuffle and pick 4-6 random predictions
    const shuffled = [...sportMarkets].sort(() => Math.random() - 0.5);
    const numPredictions = 4 + Math.floor(Math.random() * 3); // 4-6 predictions
    const selected = shuffled.slice(0, numPredictions);

    return selected.map(market => ({
        team: market.prediction,
        prediction: '',
        probability: 40 + Math.floor(Math.random() * 35), // 40-75%
        icon: market.icon,
        type: market.type,
    }));
}
// (rest of file omitted in backup summary for brevity)
